@page "/image-converter"
@using tinyutils.Services
@inject ImageConverterService ImageService
@inject AuditService AuditService
@inject IJSRuntime JS

@rendermode InteractiveServer

<PageTitle>Image Converter - tinyutils</PageTitle>

<div class="bg-white rounded-lg shadow-xl p-8 max-w-2xl mx-auto my-10">
    <h1 class="text-4xl font-extrabold text-gray-900 mb-2">Image Converter</h1>
    <p class="text-gray-600 mb-8">Convert images between JPEG, PNG, and WebP formats</p>

    <div class="mb-6 border-b pb-6 border-gray-100">
        <label class="block text-lg font-semibold text-gray-700 mb-2">
            Upload Image
        </label>
        <InputFile OnChange="HandleFileSelected" accept="image/*"
            class="block w-full text-sm text-gray-500 file:mr-4 file:py-3 file:px-6 file:rounded-full file:border-0 file:text-base file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition duration-150 ease-in-out cursor-pointer" />
    </div>

    @if (uploadedFile != null)
    {
        <div class="mb-6 p-4 bg-gray-50 rounded-lg shadow-inner">
            <p class="text-sm font-medium text-gray-800">
                <span class="font-bold">File:</span> @uploadedFile.Name (@FormatBytes(uploadedFile.Size))
            </p>
        </div>

        <div class="mb-8">
            <label class="block text-lg font-semibold text-gray-700 mb-3">
                Convert to:
            </label>
            <select @bind="selectedFormat"
                class="block w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 text-base">
                <option value="jpeg">JPEG</option>
                <option value="png">PNG</option>
                <option value="webp">WebP</option>
            </select>
        </div>

        <button @onclick="ConvertImage" disabled="@isProcessing"
            class="w-full px-6 py-3 text-lg font-semibold text-white rounded-lg shadow-md transition duration-150 ease-in-out
                                       @(isProcessing ? "bg-gray-400 cursor-not-allowed" : "bg-blue-600 hover:bg-blue-700 active:bg-blue-800")">
            @(isProcessing ? "Processing..." : "Convert Image")
        </button>
    }

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="mt-6 p-4 bg-red-50 border border-red-300 rounded-lg">
            <p class="text-red-700 font-medium">Error: @errorMessage</p>
        </div>
    }

    @if (convertedImageData != null)
    {
        <div class="mt-8 pt-8 border-t border-gray-200">
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Conversion Result</h3>

            <div class="mb-6 p-4 bg-green-50 border border-green-300 rounded-lg">
                <p class="text-green-800 font-medium">
                    ✓ Converted successfully! (@imageWidth × @imageHeight px)
                </p>
            </div>

            <img src="@convertedImageDataUrl" alt="Converted image preview"
                class="max-w-full h-auto rounded-lg shadow-xl border border-gray-200 mb-6" />

            <button @onclick="DownloadImage"
                class="w-full px-6 py-3 text-lg font-semibold text-white rounded-lg shadow-md transition duration-150 ease-in-out bg-green-600 hover:bg-green-700 active:bg-green-800">
                Download @downloadFileName
            </button>
        </div>
    }
</div>

@code {
    private IBrowserFile? uploadedFile;
    private string selectedFormat = "jpeg";
    private bool isProcessing = false;
    private string? errorMessage;
    private byte[]? convertedImageData;
    private string? convertedImageDataUrl;
    private string? downloadFileName;
    private int imageWidth;
    private int imageHeight;

    // JavaScript interop function to download a file from base64 data
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("eval", @"
window.downloadFile = function (fileName, base64Data) {
const link = document.createElement('a');
link.href = 'data:application/octet-stream;base64,' + base64Data;
link.download = fileName;
document.body.appendChild(link);
link.click();
document.body.removeChild(link);
};
");
        }
    }

    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        // Limit to only the first file if multiple were selected (InputFile allows single/multiple)
        uploadedFile = e.File;
        convertedImageData = null;
        errorMessage = null;
    }

    private async Task ConvertImage()
    {
        if (uploadedFile == null) return;

        isProcessing = true;
        errorMessage = null;
        convertedImageData = null;

        try
        {
            var startTime = DateTime.UtcNow;
            // 10MB limit
            using var stream = uploadedFile.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);

            var result = await ImageService.ConvertImageAsync(stream, selectedFormat);

            if (result.Success && result.ImageData != null)
            {
                convertedImageData = result.ImageData;
                convertedImageDataUrl = $"data:{result.ContentType};base64,{Convert.ToBase64String(result.ImageData)}";
                downloadFileName = $"converted.{result.FileExtension}";
                imageWidth = result.Width;
                imageHeight = result.Height;

                var processingTime = (DateTime.UtcNow - startTime).TotalMilliseconds;

                // Log usage (assuming ImageService/AuditService handle necessary dependency injection and implementation)
                await AuditService.LogUsageAsync(
                toolName: "Image Converter",
                inputSize: uploadedFile.Size,
                outputSize: result.ImageData.Length,
                processingTimeMs: processingTime
                );
            }
            else
            {
                errorMessage = result.ErrorMessage ?? $"Conversion to {selectedFormat.ToUpper()} failed. Please check the file format.";
            }
        }
        catch (Exception ex)
        {
            // Catch specific size exception if OpenReadStream failed
            errorMessage = $"Error processing file: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
        }
    }

    private async Task DownloadImage()
    {
        if (convertedImageData == null || string.IsNullOrEmpty(downloadFileName)) return;

        var base64 = Convert.ToBase64String(convertedImageData);
        // Invoke the JS function defined in OnAfterRenderAsync to trigger the file download
        await JS.InvokeVoidAsync("downloadFile", downloadFileName, base64);
    }

    private string FormatBytes(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024.0:F1} KB";
        return $"{bytes / (1024.0 * 1024):F1} MB";
    }
}